<!DOCTYPE html>
<html>
<head>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://raw.githack.com/AR-js-org/AR.js/master/three.js/build/ar-threex.js"></script>
</head>

<body style="margin:0; overflow:hidden;">

<script>
let scene, camera, renderer;
let markerRoot, arToolkitSource, arToolkitContext;
let mixer;
let clock = new THREE.Clock();

/* ------------------------------------------------
   ⭐ 마커 사라져도 3초 유지 기능을 위한 변수
--------------------------------------------------- */
let lastMatrix = new THREE.Matrix4();
let isMarkerVisible = false;
let lastSeenTime = Date.now();

init();
animate();

function init() {

  /* -----------------------
     기본 Scene 구성
  ------------------------ */
  scene = new THREE.Scene();

  camera = new THREE.Camera();
  scene.add(camera);

  /* -----------------------
     조명 추가
  ------------------------ */
  scene.add(new THREE.AmbientLight(0xffffff, 3.0));

  const dirLight = new THREE.DirectionalLight(0xffffff, 3.0);
  dirLight.position.set(1, 1, 1).normalize();
  scene.add(dirLight);

  /* -----------------------
     Renderer 설정
  ------------------------ */
  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(window.devicePixelRatio);
  document.body.appendChild(renderer.domElement);

  /* -----------------------
     ARToolkit 설정
  ------------------------ */
  arToolkitSource = new THREEx.ArToolkitSource({ sourceType: 'webcam' });

  arToolkitSource.init(() => {
    setTimeout(onResize, 2000);
  });

  window.addEventListener('resize', onResize);

  function onResize() {
    arToolkitSource.onResize();
    arToolkitSource.copySizeTo(renderer.domElement);
    if (arToolkitContext.arController) {
      arToolkitSource.copySizeTo(arToolkitContext.arController.canvas);
    }
  }

  arToolkitContext = new THREEx.ArToolkitContext({
    cameraParametersUrl: './camera_para.dat',
    detectionMode: 'mono'
  });

  arToolkitContext.init(() => {
    camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix());
  });

  /* -----------------------
     마커 설정
  ------------------------ */
  markerRoot = new THREE.Group();
  scene.add(markerRoot);

  const markerControls = new THREEx.ArMarkerControls(arToolkitContext, markerRoot, {
    type: 'pattern',
    patternUrl: './euv.patt',

    // 기본 플리커링 감소 옵션
    smooth: true,
    smoothCount: 5,
    smoothTolerance: 0.01,
    smoothThreshold: 2,
  });

  /* -----------------------
     glTF 로드 (애니메이션 포함)
  ------------------------ */
  const loader = new THREE.GLTFLoader();

  loader.load("./animodel.glb", (gltf) => {

    const model = gltf.scene;
    model.scale.set(0.015, 0.015, 0.015);
    model.position.set(-0.15, 0, 0.5);
    model.rotation.y = Math.PI;
    model.rotation.x = -Math.PI / 2;

    model.traverse((child) => {
      if (child.isMesh) child.frustumCulled = false;
    });

    markerRoot.add(model);

    console.log("GLB LOADED SUCCESS");

    /* -----------------------
       애니메이션 실행
    ------------------------ */
    if (gltf.animations.length > 0) {
      mixer = new THREE.AnimationMixer(model);

      gltf.animations.forEach((clip, idx) => {
        const action = mixer.clipAction(clip);
        action.reset();
        action.play();
        console.log(`Animation #${idx} started`);
      });

      console.log("ALL ANIMATIONS STARTED");
    } else {
      console.warn("⚠ glTF 파일에 애니메이션이 없습니다!");
    }
  });
}

function animate() {
  requestAnimationFrame(animate);

  if (arToolkitSource.ready) {
    arToolkitContext.update(arToolkitSource.domElement);
  }

  /* ------------------------------------------------
     ⭐ 3초 동안 마커가 사라져도 pose 유지하는 코드
  --------------------------------------------------- */

  const visible = markerRoot.visible;

  if (visible) {
    // 마커가 보일 때 pose 저장
    lastMatrix.copy(markerRoot.matrix);
    lastSeenTime = Date.now();
    isMarkerVisible = true;

  } else {
    if (isMarkerVisible) {
      const now = Date.now();
      const elapsed = now - lastSeenTime;

      if (elapsed <= 3000) { // ⭐ 3초 동안 유지
        markerRoot.matrix.copy(lastMatrix);
        markerRoot.matrixWorldNeedsUpdate = true;
        markerRoot.visible = true;
      } else {
        markerRoot.visible = false; // 3초 지나면 사라짐
      }
    }
  }

  /* -----------------------
     애니메이션 업데이트
  ------------------------ */
  const delta = clock.getDelta();
  if (mixer) mixer.update(delta);

  renderer.render(scene, camera);
}
</script>

</body>
</html>






